import * as Path from 'path';
import * as FS from 'fs-extra';

export class AstGenerator {
	static dryRun: boolean;

	static main(args: { path?: string; dryRun?: boolean }): void {
		let outputDir = args.path ?? 'packages/ts/src/lib/types';
		this.dryRun = args.dryRun ?? false;

		// prettier-ignore
		this.defineAst(outputDir, 'Expr', [
			`Assign   | name: Token, value: Expr`,
			`Binary   | left: Expr, operator: Token, right: Expr`,
			`Call     | callee: Expr, paren: Token, args: Expr[]`,
			`Grouping | expression: Expr`,
			`Literal  | value: any`,
			`Logical  | left: Expr, operator: Token, right: Expr`,
			`Unary    | operator: Token, right: Expr`,
			`Variable | name: Token`,
		], [
			`import { Token } from './token';`,
		]);

		// prettier-ignore
		this.defineAst(outputDir, 'Stmt', [
			`Block      | statements: Stmt[]`,
			`Expression | expression: Expr`,
			`Fn         | name: Token, params: Token[], body: Stmt[]`,
			`If         | condition: Expr, thenBranch: Stmt, elseBranch: Stmt`,
			`Print      | expression: Expr`,
			`Return     | keyword: Token, value: Expr`,
			`Var        | name: Token, initializer: Expr`,
			`While      | condition: Expr, body: Stmt`,
		], [
			`import { Expr } from './expr';`,
			`import { Token } from './token';`,
		]);
	}

	private static defineAst(
		outputDir: string,
		baseName: string,
		types: string[],
		imports: string[] = [],
	): void {
		let path = Path.resolve(
			process.cwd(),
			outputDir,
			`${camelToKebabCase(baseName)}.ts`,
		);
		let fileContent = [
			`// NOTE: This file is automatically generated!`,
			`// See packages/tools/src/lib/generate-ast.ts`,
			``,
			...imports,
			``,
			`export abstract class ${baseName} {`,
			`	abstract accept<R>(visitor: Visitor<R>): R;`,
			`}`,
			``,
			``,
		].join('\n');

		fileContent += this.defineVisitor(types, baseName);
		fileContent += this.defineTypes(types, baseName);

		if (this.dryRun) console.log('fileContent:\n', fileContent);
		else FS.writeFileSync(path, fileContent);
	}

	// prettier-ignore
	private static defineVisitor(types: string[], base: string): string {
		return [
			`export interface Visitor<R> {`,
			types.map((type) => {
				let { className } = generateClass(type);
				return (
			`	visit${className}${base}(${base.toLowerCase()}: ${className}): R;`
				);
			}).join('\n'),
			`}`,
		].join('\n') + '\n\n';
	}

	// prettier-ignore
	private static defineTypes(types: string[], base: string): string {
		return types.reduce((accum, type) => {
			let { className, fields } = generateClass(type);

			return accum + [
				`export class ${className} extends ${base} {`,
				fields.map(({ name, type }) =>
				`	readonly ${name}: ${type};`).join('\n'),
				``,
				`	constructor(${
						fields.map(({ name, type }) =>
							`${name}: ${type}`).join(', ')
					}) {`,
				`		super();`,
				fields.map(({ name }) =>
				`		this.${name} = ${name};`).join('\n'),
				`	}`,
				``,
				`	accept<R>(visitor: Visitor<R>): R {`,
				`		return visitor.visit${className}${base}(this);`,
				`	}`,
				`}`
			].join('\n') + '\n\n';
		}, '');
	}
}

interface Field {
	name: string;
	type: string;
}
interface Class {
	className: string;
	fields: Field[];
}

/**
 * @param input String in the format: "<className> | <fieldName>: <fieldType>, <fieldName>: <fieldType>..."
 */
function generateClass(input: string): Class {
	let [className, fields] = input.split('|').map((str) => str.trim());
	return {
		className,
		fields: generateFields(fields),
	};
}

/**
 * @param input String in the format: "name: type, name: type..."
 */
function generateFields(input: string): Field[] {
	return input
		.split(',')
		.map((field) => field.trim().split(':'))
		.map(([name, type]) => ({
			name: name.trim(),
			type: type.trim(),
		}));
}

function camelToKebabCase(text: string): string {
	return text.replace(/([a-z])([A-Z0-9])/g, '$1-$2').toLowerCase();
}

// NOTE: This file is automatically generated!
// See packages/tools/src/lib/generate-ast.ts

import * as Expr from './expr';
import { Token } from './token';

export abstract class Stmt {
	abstract accept<R>(visitor: Visitor<R>): R;
}

export interface Visitor<R> {
	visitBlockStmt(stmt: Block): R;
	visitExpressionStmt(stmt: Expression): R;
	visitFnStmt(stmt: Fn): R;
	visitIfStmt(stmt: If): R;
	visitPrintStmt(stmt: Print): R;
	visitReturnStmt(stmt: Return): R;
	visitVarStmt(stmt: Var): R;
	visitWhileStmt(stmt: While): R;
}

export class Block extends Stmt {
	readonly statements: Stmt[];

	constructor(statements: Stmt[]) {
		super();
		this.statements = statements;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitBlockStmt(this);
	}
}

export class Expression extends Stmt {
	readonly expression: Expr.Expr;

	constructor(expression: Expr.Expr) {
		super();
		this.expression = expression;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitExpressionStmt(this);
	}
}

export class Fn extends Stmt {
	readonly name: Token;
	readonly func: Expr.Fn;

	constructor(name: Token, func: Expr.Fn) {
		super();
		this.name = name;
		this.func = func;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitFnStmt(this);
	}
}

export class If extends Stmt {
	readonly condition: Expr.Expr;
	readonly thenBranch: Stmt;
	readonly elseBranch: Stmt;

	constructor(condition: Expr.Expr, thenBranch: Stmt, elseBranch: Stmt) {
		super();
		this.condition = condition;
		this.thenBranch = thenBranch;
		this.elseBranch = elseBranch;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitIfStmt(this);
	}
}

export class Print extends Stmt {
	readonly expression: Expr.Expr;

	constructor(expression: Expr.Expr) {
		super();
		this.expression = expression;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitPrintStmt(this);
	}
}

export class Return extends Stmt {
	readonly keyword: Token;
	readonly value: Expr.Expr;

	constructor(keyword: Token, value: Expr.Expr) {
		super();
		this.keyword = keyword;
		this.value = value;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitReturnStmt(this);
	}
}

export class Var extends Stmt {
	readonly name: Token;
	readonly initializer: Expr.Expr;

	constructor(name: Token, initializer: Expr.Expr) {
		super();
		this.name = name;
		this.initializer = initializer;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitVarStmt(this);
	}
}

export class While extends Stmt {
	readonly condition: Expr.Expr;
	readonly body: Stmt;

	constructor(condition: Expr.Expr, body: Stmt) {
		super();
		this.condition = condition;
		this.body = body;
	}

	accept<R>(visitor: Visitor<R>): R {
		return visitor.visitWhileStmt(this);
	}
}

